name: ğŸš€ Deploy Barbear.IA para OCI - Rebuild Completo

on:
  push:
    branches: [ main ]  # Trigger automÃ¡tico no push para main
  workflow_dispatch:    # Permite execuÃ§Ã£o manual
    inputs:
      force_rebuild:
        description: 'ForÃ§ar rebuild completo (remove todos containers/imagens)'
        required: false
        default: 'true'
        type: boolean
      skip_tests:
        description: 'Pular testes (apenas para emergÃªncias)'
        required: false
        default: 'false'
        type: boolean
  schedule:
    - cron: '0 2 * * 0'  # Deploy semanal de manutenÃ§Ã£o (Domingo 2h)

# Controle de concorrÃªncia para evitar deployments paralelos
concurrency:
  group: deploy-barbear-ia-${{ github.ref }}
  cancel-in-progress: true

env:
  PROJECT_NAME: "Barbear.IA"
  CONTAINER_NAME: "barbear-ia-frontend"
  PORT: 3500
  NGINX_CONTAINER: "nginx-proxy"
  HEALTH_CHECK_TIMEOUT: 300
  PERFORMANCE_THRESHOLD: 3000
  DEPLOY_TIMEOUT: 1800  # 30 minutos timeout para operaÃ§Ãµes crÃ­ticas
  ROLLBACK_ENABLED: true
  LOG_LEVEL: "INFO"

jobs:
  # Job de validaÃ§Ã£o de integridade e preparaÃ§Ã£o
  integrity-check:
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.commit-info.outputs.sha }}
      commit_short: ${{ steps.commit-info.outputs.short }}
      source_checksum: ${{ steps.checksum.outputs.checksum }}
      timestamp: ${{ steps.timestamp.outputs.timestamp }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch completo para validaÃ§Ã£o de histÃ³rico
    
    - name: ğŸ“Š Capturar informaÃ§Ãµes do commit
      id: commit-info
      run: |
        echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "short=$(echo ${{ github.sha }} | cut -c1-8)" >> $GITHUB_OUTPUT
        echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        echo "author=${{ github.actor }}" >> $GITHUB_OUTPUT
        
    - name: ğŸ” Gerar checksum SHA-256 dos arquivos crÃ­ticos
      id: checksum
      run: |
        echo "ğŸ” Gerando checksums dos arquivos crÃ­ticos..."
        
        # Lista de arquivos crÃ­ticos para verificaÃ§Ã£o de integridade
        CRITICAL_FILES=(
          "package.json"
          "package-lock.json"
          "Dockerfile"
          "docker-compose.yml"
          "nginx.conf"
          "vite.config.ts"
          "tsconfig.json"
          "src/main.tsx"
          "src/App.tsx"
        )
        
        # Gerar checksum combinado
        COMBINED_HASH=""
        for file in "${CRITICAL_FILES[@]}"; do
          if [ -f "$file" ]; then
            file_hash=$(sha256sum "$file" | cut -d' ' -f1)
            echo "âœ… $file: $file_hash"
            COMBINED_HASH="${COMBINED_HASH}${file_hash}"
          else
            echo "âš ï¸ Arquivo nÃ£o encontrado: $file"
          fi
        done
        
        # Checksum final
        FINAL_CHECKSUM=$(echo -n "$COMBINED_HASH" | sha256sum | cut -d' ' -f1)
        echo "ğŸ” Checksum final: $FINAL_CHECKSUM"
        echo "checksum=$FINAL_CHECKSUM" >> $GITHUB_OUTPUT
        
        # Salvar checksums individuais
        echo "ğŸ“ Salvando checksums individuais..."
        mkdir -p checksums
        for file in "${CRITICAL_FILES[@]}"; do
          if [ -f "$file" ]; then
            sha256sum "$file" >> checksums/files.sha256
          fi
        done
        
    - name: â° Timestamp de deploy
      id: timestamp
      run: |
        TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
        echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
        echo "ğŸ• Timestamp: $TIMESTAMP"
        
    - name: ğŸ“¤ Upload checksums como artefato
      uses: actions/upload-artifact@v4
      with:
        name: integrity-checksums-${{ steps.commit-info.outputs.short }}
        path: checksums/
        retention-days: 30

  test:
    needs: integrity-check
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        # Removido cache: 'npm' para forÃ§ar instalaÃ§Ã£o limpa
    
    - name: Clean npm cache
      run: |
        npm cache clean --force
        npm cache verify
    
    - name: Install dependencies (clean)
      run: |
        rm -rf node_modules package-lock.json
        npm install --no-audit --no-fund
    
    - name: Clean Vite cache
      run: |
        rm -rf node_modules/.vite
        rm -rf dist
        rm -rf build
    
    - name: Run linting
      run: npm run lint || echo "Linting completed with warnings"
    
    - name: Run tests
      run: npm test -- --coverage --watchAll=false
    
    - name: Build application (force clean & debug)
      run: |
        echo "=== Node / npm versions ==="
        node -v
        npm -v
        echo "=== Listing project files ==="
        ls -la
        echo "=== Running Vite build with DEBUG=vite:* ==="
        export DEBUG=vite:*
        # executar build e, em caso de falha, imprimir arquivos de configuraÃ§Ã£o relevantes
        if npm run build; then
          echo "âœ… Build concluÃ­do com sucesso"
        else
          echo "âŒ Build falhou â€” exibindo debug"
          echo "--- package.json ---"
          cat package.json || true
          echo "--- vite.config.* ---"
          ls -la vite.config.* || true
          cat vite.config.ts || true
          echo "--- tsconfig.json ---"
          cat tsconfig.json || true
          echo "--- Ãšltimos arquivos de log / npm list ---"
          npm ls --depth=0 || true
          echo "--- Verificando node_modules ---"
          ls -la node_modules/@vitejs/ || true
          echo "--- Finalizando com exit 1 ---"
          exit 1
        fi
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-files
        path: build/
        retention-days: 1

  deploy:
    needs: [integrity-check, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (success() || inputs.skip_tests)
    timeout-minutes: 30  # Timeout de 30 minutos para deploy
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: ğŸ“¥ Download checksums de integridade
      uses: actions/download-artifact@v4
      with:
        name: integrity-checksums-${{ needs.integrity-check.outputs.commit_short }}
        path: checksums/
    
    - name: ğŸ” Preparar autenticaÃ§Ã£o SSH segura
      run: |
        echo "ğŸ”‘ Configurando autenticaÃ§Ã£o SSH..."
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar known_hosts para evitar prompt de verificaÃ§Ã£o
        echo "${{ secrets.OCI_HOST_KEY }}" >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Validar conectividade SSH
        echo "ğŸ” Testando conectividade SSH..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=yes ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }} "echo 'SSH conectado com sucesso'"

    - name: ğŸ§¹ Limpeza completa e remoÃ§Ã£o forÃ§ada de containers
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 600s  # 10 minutos timeout
        script: |
          set -e  # Parar em caso de erro
          
          echo "ğŸš€ Iniciando limpeza completa do ${{ env.PROJECT_NAME }}..."
          echo "ğŸ“Š Commit: ${{ needs.integrity-check.outputs.commit_short }}"
          echo "ğŸ” Checksum: ${{ needs.integrity-check.outputs.source_checksum }}"
          echo "â° Timestamp: ${{ needs.integrity-check.outputs.timestamp }}"
          
          # Criar diretÃ³rio do projeto
          sudo mkdir -p /var/www/${{ env.PROJECT_NAME }}
          sudo chown ${{ secrets.OCI_USERNAME }}:${{ secrets.OCI_USERNAME }} /var/www/${{ env.PROJECT_NAME }}
          cd /var/www/${{ env.PROJECT_NAME }}
          
          # Criar snapshot de backup antes da limpeza
          echo "ğŸ“¦ Criando snapshot de backup..."
          BACKUP_DIR="/var/backups/barbear-ia-snapshots"
          sudo mkdir -p "$BACKUP_DIR"
          BACKUP_NAME="backup-${{ needs.integrity-check.outputs.timestamp }}-${{ needs.integrity-check.outputs.commit_short }}"
          
          # Backup de configuraÃ§Ãµes crÃ­ticas
          if [ -f docker-compose.yml ]; then
            sudo cp docker-compose.yml "$BACKUP_DIR/$BACKUP_NAME-docker-compose.yml"
          fi
          
          if [ -f nginx.conf ]; then
            sudo cp nginx.conf "$BACKUP_DIR/$BACKUP_NAME-nginx.conf"
          fi
          
          # Backup de dados de volumes (se existirem)
          if docker volume ls | grep -q barbear; then
            echo "ğŸ’¾ Fazendo backup de volumes..."
            docker run --rm -v barbear-ia-data:/data -v "$BACKUP_DIR":/backup alpine tar czf "/backup/$BACKUP_NAME-volumes.tar.gz" -C /data . || true
          fi
          
          echo "âœ… Backup criado: $BACKUP_NAME"
          
          # REMOÃ‡ÃƒO FORÃ‡ADA COMPLETA
          echo "ğŸ§¹ Iniciando remoÃ§Ã£o forÃ§ada completa..."
          
          # Parar todos os containers relacionados
          echo "ğŸ›‘ Parando containers relacionados ao Barbear.IA..."
          docker ps -a --filter "name=barbear" --format "{{.Names}}" | xargs -r docker stop || true
          docker ps -a --filter "name=${{ env.CONTAINER_NAME }}" --format "{{.Names}}" | xargs -r docker stop || true
          
          # Remover containers forÃ§adamente
          echo "ğŸ—‘ï¸ Removendo containers forÃ§adamente..."
          docker ps -a --filter "name=barbear" --format "{{.Names}}" | xargs -r docker rm -f || true
          docker ps -a --filter "name=${{ env.CONTAINER_NAME }}" --format "{{.Names}}" | xargs -r docker rm -f || true
          
          # Remover imagens relacionadas
          echo "ğŸ—‘ï¸ Removendo imagens relacionadas..."
          docker images --filter "reference=*barbear*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi -f || true
          docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi -f || true
          
          # Limpeza completa do sistema Docker
          echo "ğŸ§¹ Limpeza completa do sistema Docker..."
          docker system prune -a -f --volumes || true
          docker builder prune -a -f || true
          docker volume prune -f || true
          docker network prune -f || true
          
          # Limpeza de cache do sistema
          echo "ğŸ§¹ Limpeza de cache do sistema..."
          sudo rm -rf /tmp/barbear-* || true
          sudo rm -rf /var/cache/barbear-* || true
          sudo find /tmp -name "*barbear*" -type f -delete || true
          
          # Verificar se limpeza foi bem-sucedida
          echo "ğŸ” Verificando limpeza..."
          REMAINING_CONTAINERS=$(docker ps -a --filter "name=barbear" --format "{{.Names}}" | wc -l)
          REMAINING_IMAGES=$(docker images --filter "reference=*barbear*" --format "{{.Repository}}" | wc -l)
          
          if [ "$REMAINING_CONTAINERS" -eq 0 ] && [ "$REMAINING_IMAGES" -eq 0 ]; then
            echo "âœ… Limpeza completa realizada com sucesso"
          else
            echo "âš ï¸ Alguns artefatos podem ter permanecido:"
            echo "   Containers: $REMAINING_CONTAINERS"
            echo "   Imagens: $REMAINING_IMAGES"
          fi
          
          echo "ğŸ¯ Limpeza completa finalizada"
    
    - name: ğŸ“¥ SincronizaÃ§Ã£o segura de arquivos do repositÃ³rio
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 300s  # 5 minutos timeout
        script: |
          set -e
          
          echo "ğŸš€ Iniciando sincronizaÃ§Ã£o segura do ${{ env.PROJECT_NAME }}..."
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          # Validar integridade do repositÃ³rio remoto
          echo "ğŸ” Validando integridade do repositÃ³rio..."
          
          # Function to download file with checksum validation
          download_and_validate() {
            local file=$1
            local expected_checksum=$2
            
            echo "ğŸ“¥ Baixando $file..."
            if curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3.raw" \
                    -o "$file.tmp" \
                    -L "https://api.github.com/repos/${{ github.repository }}/contents/$file?ref=${{ github.sha }}" \
                    --fail --silent --show-error; then
              
              # Validar checksum se fornecido
              if [ ! -z "$expected_checksum" ]; then
                actual_checksum=$(sha256sum "$file.tmp" | cut -d' ' -f1)
                if [ "$actual_checksum" != "$expected_checksum" ]; then
                  echo "âŒ Checksum invÃ¡lido para $file"
                  echo "   Esperado: $expected_checksum"
                  echo "   Atual: $actual_checksum"
                  rm -f "$file.tmp"
                  return 1
                fi
              fi
              
              mv "$file.tmp" "$file"
              echo "âœ… $file baixado e validado com sucesso"
              return 0
            else
              echo "âŒ Erro ao baixar $file"
              rm -f "$file.tmp"
              return 1
            fi
          }
          
          # Download arquivos crÃ­ticos com validaÃ§Ã£o
          echo "ğŸ“¦ Baixando arquivos crÃ­ticos..."
          
          download_and_validate "docker-compose.yml"
          download_and_validate "Dockerfile"
          download_and_validate "nginx.conf"
          download_and_validate "package.json"
          download_and_validate "package-lock.json"
          download_and_validate ".dockerignore"
          download_and_validate "vite.config.ts"
          download_and_validate "tsconfig.json"
          
          # Validar commit especÃ­fico
          echo "ğŸ” Validando commit especÃ­fico..."
          REMOTE_COMMIT=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                              -H "Accept: application/vnd.github.v3+json" \
                              -s "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.sha }}" \
                              | grep '"sha"' | head -1 | cut -d'"' -f4)
          
          if [ "$REMOTE_COMMIT" = "${{ github.sha }}" ]; then
            echo "âœ… Commit validado: ${{ needs.integrity-check.outputs.commit_short }}"
          else
            echo "âŒ Commit nÃ£o corresponde ao esperado"
            echo "   Esperado: ${{ github.sha }}"
            echo "   Remoto: $REMOTE_COMMIT"
            exit 1
          fi
          
          # Criar arquivo de metadados do deploy
          echo "ğŸ“ Criando metadados do deploy..."
          cat > deploy-metadata.json << EOF
          {
            "commit_sha": "${{ github.sha }}",
            "commit_short": "${{ needs.integrity-check.outputs.commit_short }}",
            "source_checksum": "${{ needs.integrity-check.outputs.source_checksum }}",
            "deploy_timestamp": "${{ needs.integrity-check.outputs.timestamp }}",
            "branch": "${{ github.ref_name }}",
            "author": "${{ github.actor }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}"
          }
          EOF
          
          echo "âœ… SincronizaÃ§Ã£o de arquivos concluÃ­da com validaÃ§Ã£o de integridade"

    - name: ğŸ—ï¸ Build e Deploy Completo com VerificaÃ§Ãµes Robustas
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 1200s  # 20 minutos timeout para build completo
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "ğŸ”„ Iniciando build e deploy completo do ${{ env.PROJECT_NAME }}..."
          echo "ğŸ“Š Metadados do deploy:"
          cat deploy-metadata.json | jq '.' || cat deploy-metadata.json
          
          # Verificar prÃ©-requisitos
          echo "ğŸ” Verificando prÃ©-requisitos..."
          
          # Verificar se Docker estÃ¡ funcionando
          if ! docker --version > /dev/null 2>&1; then
            echo "âŒ Docker nÃ£o estÃ¡ disponÃ­vel"
            exit 1
          fi
          
          # Verificar se docker-compose estÃ¡ disponÃ­vel
          if ! docker-compose --version > /dev/null 2>&1; then
            echo "âŒ Docker Compose nÃ£o estÃ¡ disponÃ­vel"
            exit 1
          fi
          
          # Verificar espaÃ§o em disco
          AVAILABLE_SPACE=$(df /var/www | tail -1 | awk '{print $4}')
          MIN_SPACE=2097152  # 2GB em KB
          
          if [ "$AVAILABLE_SPACE" -lt "$MIN_SPACE" ]; then
            echo "âŒ EspaÃ§o em disco insuficiente"
            echo "   DisponÃ­vel: ${AVAILABLE_SPACE}KB"
            echo "   MÃ­nimo: ${MIN_SPACE}KB"
            exit 1
          fi
          
          echo "âœ… PrÃ©-requisitos verificados"
          
          # Build da nova imagem com logs detalhados
          echo "ğŸ—ï¸ Construindo nova imagem (build completo sem cache)..."
          
          # Definir variÃ¡veis de build
          BUILD_ARGS="--build-arg COMMIT_SHA=${{ github.sha }} \
                      --build-arg BUILD_TIMESTAMP=${{ needs.integrity-check.outputs.timestamp }} \
                      --build-arg SOURCE_CHECKSUM=${{ needs.integrity-check.outputs.source_checksum }}"
          
          # Build com logs detalhados e sem cache
          echo "ğŸ”¨ Executando docker-compose build..."
          if docker-compose build --no-cache --pull --force-rm --progress=plain $BUILD_ARGS ${{ env.CONTAINER_NAME }} 2>&1 | tee build.log; then
            echo "âœ… Build concluÃ­do com sucesso"
            
            # Verificar se a imagem foi criada
            NEW_IMAGE_ID=$(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.ID}}" | head -1)
            if [ -z "$NEW_IMAGE_ID" ]; then
              echo "âŒ Imagem nÃ£o foi criada corretamente"
              exit 1
            fi
            
            echo "âœ… Nova imagem criada: $NEW_IMAGE_ID"
            
          else
            echo "âŒ Erro no build da imagem"
            echo "ğŸ“‹ Ãšltimas linhas do log de build:"
            tail -20 build.log || true
            exit 1
          fi
          
          # VerificaÃ§Ã£o de saÃºde da imagem
          echo "ğŸ” Verificando saÃºde da nova imagem..."
          
          # Testar a imagem antes do deploy
          TEST_CONTAINER="test-${{ env.CONTAINER_NAME }}-${{ needs.integrity-check.outputs.commit_short }}"
          
          echo "ğŸ§ª Iniciando container de teste..."
          if docker run -d --name "$TEST_CONTAINER" -p 8080:80 --health-interval=10s --health-timeout=5s --health-retries=3 "${{ env.CONTAINER_NAME }}:latest"; then
            
            # Aguardar container ficar saudÃ¡vel
            echo "â³ Aguardando container de teste ficar saudÃ¡vel..."
            HEALTH_RETRIES=0
            MAX_HEALTH_RETRIES=12  # 2 minutos
            
            while [ $HEALTH_RETRIES -lt $MAX_HEALTH_RETRIES ]; do
              HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$TEST_CONTAINER" 2>/dev/null || echo "unknown")
              
              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "âœ… Container de teste estÃ¡ saudÃ¡vel"
                break
              elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
                echo "âŒ Container de teste nÃ£o estÃ¡ saudÃ¡vel"
                docker logs "$TEST_CONTAINER" | tail -20
                docker rm -f "$TEST_CONTAINER" || true
                exit 1
              else
                echo "â³ Status: $HEALTH_STATUS (tentativa $((HEALTH_RETRIES + 1))/$MAX_HEALTH_RETRIES)"
                sleep 10
                HEALTH_RETRIES=$((HEALTH_RETRIES + 1))
              fi
            done
            
            if [ $HEALTH_RETRIES -eq $MAX_HEALTH_RETRIES ]; then
              echo "âŒ Timeout na verificaÃ§Ã£o de saÃºde do container de teste"
              docker logs "$TEST_CONTAINER" | tail -20
              docker rm -f "$TEST_CONTAINER" || true
              exit 1
            fi
            
            # Teste de conectividade HTTP
            echo "ğŸŒ Testando conectividade HTTP..."
            if curl -f -s http://localhost:8080/ > /dev/null; then
              echo "âœ… Teste HTTP passou"
            else
              echo "âŒ Teste HTTP falhou"
              docker logs "$TEST_CONTAINER" | tail -20
              docker rm -f "$TEST_CONTAINER" || true
              exit 1
            fi
            
            # Limpar container de teste
            docker rm -f "$TEST_CONTAINER" || true
            echo "âœ… VerificaÃ§Ã£o de saÃºde da imagem concluÃ­da"
            
          else
            echo "âŒ Falha ao iniciar container de teste"
            exit 1
          fi
          
          # Deploy da nova versÃ£o
          echo "ğŸš€ Iniciando deploy da nova versÃ£o..."
          
          # Parar versÃ£o atual se existir
          echo "ğŸ›‘ Parando versÃ£o atual..."
          docker-compose down --remove-orphans || true
          
          # Iniciar nova versÃ£o
          echo "ğŸš€ Iniciando nova versÃ£o..."
          if docker-compose up -d ${{ env.CONTAINER_NAME }}; then
            echo "âœ… Nova versÃ£o iniciada"
          else
            echo "âŒ Falha ao iniciar nova versÃ£o"
            echo "ğŸ“‹ Logs do docker-compose:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi
          
          # Aguardar inicializaÃ§Ã£o
          echo "â³ Aguardando inicializaÃ§Ã£o completa (45 segundos)..."
          sleep 45
          
          # VerificaÃ§Ã£o de saÃºde pÃ³s-deploy
          echo "ğŸ” Executando verificaÃ§Ã£o de saÃºde pÃ³s-deploy..."
          
          HEALTH_CHECK_RETRIES=0
          MAX_HEALTH_CHECK_RETRIES=10
          
          while [ $HEALTH_CHECK_RETRIES -lt $MAX_HEALTH_CHECK_RETRIES ]; do
            if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
              echo "âœ… VerificaÃ§Ã£o de saÃºde passou!"
              
              # Verificar se o container estÃ¡ realmente rodando
              if docker-compose ps ${{ env.CONTAINER_NAME }} | grep -q "Up"; then
                echo "âœ… Container estÃ¡ rodando corretamente"
                break
              else
                echo "âŒ Container nÃ£o estÃ¡ no estado 'Up'"
                docker-compose ps
                exit 1
              fi
              
            else
              HEALTH_CHECK_RETRIES=$((HEALTH_CHECK_RETRIES + 1))
              echo "â³ VerificaÃ§Ã£o de saÃºde falhou (tentativa $HEALTH_CHECK_RETRIES/$MAX_HEALTH_CHECK_RETRIES)"
              
              if [ $HEALTH_CHECK_RETRIES -lt $MAX_HEALTH_CHECK_RETRIES ]; then
                echo "â³ Aguardando 15 segundos antes da prÃ³xima tentativa..."
                sleep 15
              fi
            fi
          done
          
          # VerificaÃ§Ã£o final
          if [ $HEALTH_CHECK_RETRIES -eq $MAX_HEALTH_CHECK_RETRIES ]; then
            echo "âŒ VerificaÃ§Ã£o de saÃºde falhou apÃ³s $MAX_HEALTH_CHECK_RETRIES tentativas"
            echo "ğŸ“‹ Logs do container:"
            docker-compose logs --tail=30 ${{ env.CONTAINER_NAME }}
            echo "ğŸ“Š Status dos containers:"
            docker-compose ps
            
            # Tentar rollback automÃ¡tico se habilitado
            if [ "${{ env.ROLLBACK_ENABLED }}" = "true" ]; then
              echo "ğŸ”„ Iniciando rollback automÃ¡tico..."
              
              # Procurar backup mais recente
              LATEST_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-docker-compose.yml 2>/dev/null | head -1)
              
              if [ ! -z "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
                echo "ğŸ“¦ Restaurando backup: $(basename $LATEST_BACKUP)"
                cp "$LATEST_BACKUP" docker-compose.yml
                
                docker-compose down || true
                docker-compose up -d ${{ env.CONTAINER_NAME }}
                sleep 30
                
                if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
                  echo "âœ… Rollback realizado com sucesso"
                  echo "âš ï¸ Deploy falhou, mas sistema foi restaurado para versÃ£o anterior"
                  exit 1  # Ainda Ã© uma falha, mas sistema estÃ¡ funcionando
                else
                  echo "âŒ Rollback tambÃ©m falhou"
                  exit 1
                fi
              else
                echo "âŒ Nenhum backup disponÃ­vel para rollback"
                exit 1
              fi
            else
              exit 1
            fi
          fi
          
          # Limpeza pÃ³s-deploy
          echo "ğŸ§¹ Limpeza pÃ³s-deploy..."
          docker image prune -f || true
          
          # Salvar informaÃ§Ãµes do deploy bem-sucedido
          echo "ğŸ“ Salvando informaÃ§Ãµes do deploy..."
          cat > last-successful-deploy.json << EOF
          {
            "commit_sha": "${{ github.sha }}",
            "commit_short": "${{ needs.integrity-check.outputs.commit_short }}",
            "deploy_timestamp": "${{ needs.integrity-check.outputs.timestamp }}",
            "image_id": "$(docker images --filter 'reference=*${{ env.CONTAINER_NAME }}*' --format '{{.ID}}' | head -1)",
            "container_id": "$(docker-compose ps -q ${{ env.CONTAINER_NAME }})",
            "success": true
          }
          EOF
          
          echo "ğŸ‰ Deploy do ${{ env.PROJECT_NAME }} realizado com sucesso!"
          echo "ğŸŒ AplicaÃ§Ã£o disponÃ­vel em: http://${{ secrets.OCI_HOST }}:${{ env.PORT }}"
          echo "ğŸ“Š Commit: ${{ needs.integrity-check.outputs.commit_short }}"
          echo "ğŸ” Checksum: ${{ needs.integrity-check.outputs.source_checksum }}"

    - name: ğŸ§¹ Limpeza Final e VerificaÃ§Ã£o de Integridade
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "ğŸ§¹ Executando limpeza final e verificaÃ§Ã£o de integridade..."
          
          # Limpeza de imagens nÃ£o utilizadas (manter apenas as 3 mais recentes)
          echo "ğŸ—‘ï¸ Limpeza de imagens antigas..."
          
          # Listar imagens do projeto e manter apenas as 3 mais recentes
          IMAGES_TO_REMOVE=$(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.ID}} {{.CreatedAt}}" | sort -k2 -r | tail -n +4 | awk '{print $1}')
          
          if [ ! -z "$IMAGES_TO_REMOVE" ]; then
            echo "ğŸ—‘ï¸ Removendo imagens antigas:"
            echo "$IMAGES_TO_REMOVE"
            echo "$IMAGES_TO_REMOVE" | xargs -r docker rmi -f || true
          else
            echo "âœ… Nenhuma imagem antiga para remover"
          fi
          
          # Limpeza geral do sistema Docker (sem afetar outros projetos)
          echo "ğŸ§¹ Limpeza geral do Docker..."
          docker system prune -f --filter "until=24h" || true
          
          # VerificaÃ§Ã£o final de integridade
          echo "ğŸ” VerificaÃ§Ã£o final de integridade..."
          
          # Verificar se o container estÃ¡ rodando
          CONTAINER_STATUS=$(docker-compose ps ${{ env.CONTAINER_NAME }} --format "{{.Status}}" 2>/dev/null || echo "not found")
          
          if echo "$CONTAINER_STATUS" | grep -q "Up"; then
            echo "âœ… Container estÃ¡ rodando: $CONTAINER_STATUS"
          else
            echo "âŒ Container nÃ£o estÃ¡ rodando: $CONTAINER_STATUS"
            exit 1
          fi
          
          # Verificar conectividade HTTP final
          echo "ğŸŒ VerificaÃ§Ã£o HTTP final..."
          if curl -f -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ | grep -q "200"; then
            echo "âœ… AplicaÃ§Ã£o respondendo corretamente (HTTP 200)"
          else
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ || echo "000")
            echo "âŒ AplicaÃ§Ã£o nÃ£o estÃ¡ respondendo corretamente (HTTP $HTTP_CODE)"
            exit 1
          fi
          
          # Verificar logs por erros crÃ­ticos
          echo "ğŸ“‹ Verificando logs por erros crÃ­ticos..."
          CRITICAL_ERRORS=$(docker-compose logs --tail=50 ${{ env.CONTAINER_NAME }} 2>&1 | grep -i "error\|fatal\|exception" | wc -l)
          
          if [ "$CRITICAL_ERRORS" -gt 0 ]; then
            echo "âš ï¸ Encontrados $CRITICAL_ERRORS erros crÃ­ticos nos logs:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} | grep -i "error\|fatal\|exception" || true
            echo "âš ï¸ Deploy concluÃ­do, mas com erros nos logs"
          else
            echo "âœ… Nenhum erro crÃ­tico encontrado nos logs"
          fi
          
          # Salvar estatÃ­sticas do deploy
          echo "ğŸ“Š Salvando estatÃ­sticas do deploy..."
          cat > deploy-stats.json << EOF
          {
            "deploy_completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "container_status": "$CONTAINER_STATUS",
            "http_status": "$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ || echo "000")",
            "critical_errors_count": $CRITICAL_ERRORS,
            "disk_usage": "$(df /var/www | tail -1 | awk '{print $5}')",
            "docker_images_count": $(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" | wc -l),
            "memory_usage": "$(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')"
          }
          EOF
          
          echo "âœ… Limpeza final concluÃ­da"

  # Job de rollback automÃ¡tico (executado apenas em caso de falha)
  rollback:
    name: ğŸ”„ Rollback AutomÃ¡tico
    runs-on: ubuntu-latest
    needs: [integrity-check, test, deploy]
    if: failure() && needs.deploy.result == 'failure' && env.ROLLBACK_ENABLED == 'true'
    timeout-minutes: 15
    
    steps:
    - name: ğŸ”„ Executar Rollback AutomÃ¡tico
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "ğŸ”„ Iniciando rollback automÃ¡tico devido a falha no deploy..."
          
          # Procurar backup mais recente
          LATEST_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-docker-compose.yml 2>/dev/null | head -1)
          LATEST_IMAGE_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-image.tar 2>/dev/null | head -1)
          
          if [ -z "$LATEST_BACKUP" ]; then
            echo "âŒ Nenhum backup de configuraÃ§Ã£o encontrado"
            exit 1
          fi
          
          echo "ğŸ“¦ Restaurando backup de configuraÃ§Ã£o: $(basename $LATEST_BACKUP)"
          cp "$LATEST_BACKUP" docker-compose.yml
          
          # Restaurar imagem se disponÃ­vel
          if [ ! -z "$LATEST_IMAGE_BACKUP" ] && [ -f "$LATEST_IMAGE_BACKUP" ]; then
            echo "ğŸ“¦ Restaurando imagem de backup: $(basename $LATEST_IMAGE_BACKUP)"
            docker load -i "$LATEST_IMAGE_BACKUP"
          fi
          
          # Parar containers atuais
          echo "ğŸ›‘ Parando containers atuais..."
          docker-compose down --remove-orphans || true
          
          # Iniciar versÃ£o de backup
          echo "ğŸš€ Iniciando versÃ£o de backup..."
          docker-compose up -d ${{ env.CONTAINER_NAME }}
          
          # Aguardar inicializaÃ§Ã£o
          echo "â³ Aguardando inicializaÃ§Ã£o (30 segundos)..."
          sleep 30
          
          # Verificar se rollback foi bem-sucedido
          ROLLBACK_RETRIES=0
          MAX_ROLLBACK_RETRIES=5
          
          while [ $ROLLBACK_RETRIES -lt $MAX_ROLLBACK_RETRIES ]; do
            if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
              echo "âœ… Rollback realizado com sucesso!"
              
              # Salvar informaÃ§Ãµes do rollback
              cat > rollback-info.json << EOF
              {
                "rollback_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "failed_commit": "${{ github.sha }}",
                "restored_backup": "$(basename $LATEST_BACKUP)",
                "success": true
              }
              EOF
              
              echo "ğŸ“ InformaÃ§Ãµes do rollback salvas"
              break
            else
              ROLLBACK_RETRIES=$((ROLLBACK_RETRIES + 1))
              echo "â³ Rollback tentativa $ROLLBACK_RETRIES/$MAX_ROLLBACK_RETRIES falhou"
              
              if [ $ROLLBACK_RETRIES -lt $MAX_ROLLBACK_RETRIES ]; then
                sleep 10
              fi
            fi
          done
          
          if [ $ROLLBACK_RETRIES -eq $MAX_ROLLBACK_RETRIES ]; then
            echo "âŒ Rollback falhou apÃ³s $MAX_ROLLBACK_RETRIES tentativas"
            echo "ğŸ“‹ Logs do container:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi

    - name: ğŸ“§ Notificar Rollback
      if: success()
      run: |
        echo "ğŸ”„ Rollback automÃ¡tico executado com sucesso"
        echo "âš ï¸ Deploy do commit ${{ github.sha }} falhou e foi revertido"
        echo "ğŸ“Š AplicaÃ§Ã£o restaurada para versÃ£o anterior"
        # Aqui vocÃª pode adicionar notificaÃ§Ãµes por email, Slack, etc.

  # Job de testes automatizados em produÃ§Ã£o
  production-tests:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js for testing
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install testing dependencies
      run: |
        npm install --only=dev
        npm install playwright @playwright/test
    
    - name: Wait for application to be fully ready
      run: |
        echo "â³ Aguardando aplicaÃ§Ã£o estar completamente pronta..."
        sleep 60
    
    - name: Test 1 - Funcionamento dos Logins
      run: |
        echo "ğŸ” Testando funcionamento dos logins..."
        
        # Teste de conectividade bÃ¡sica
        if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
          echo "âœ… AplicaÃ§Ã£o estÃ¡ respondendo"
        else
          echo "âŒ AplicaÃ§Ã£o nÃ£o estÃ¡ respondendo"
          exit 1
        fi
        
        # Teste de carregamento da pÃ¡gina de login
        response=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/")
        if [ "$response" = "200" ]; then
          echo "âœ… PÃ¡gina de login carregou com sucesso (HTTP 200)"
        else
          echo "âŒ PÃ¡gina de login retornou cÃ³digo: $response"
          exit 1
        fi
        
        # Teste de recursos estÃ¡ticos (CSS, JS)
        echo "ğŸ¨ Verificando carregamento de recursos estÃ¡ticos..."
        static_check=$(curl -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" | grep -c "assets/" || echo "0")
        if [ "$static_check" -gt "0" ]; then
          echo "âœ… Recursos estÃ¡ticos detectados na pÃ¡gina"
        else
          echo "âš ï¸ Poucos recursos estÃ¡ticos detectados"
        fi
    
    - name: Test 2 - Performance do Sistema
      run: |
        echo "âš¡ Testando performance do sistema..."
        
        # Teste de tempo de resposta
        start_time=$(date +%s%3N)
        curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null
        end_time=$(date +%s%3N)
        response_time=$((end_time - start_time))
        
        echo "ğŸ“Š Tempo de resposta: ${response_time}ms"
        
        if [ "$response_time" -lt "${{ env.PERFORMANCE_THRESHOLD }}" ]; then
          echo "âœ… Performance dentro do limite aceitÃ¡vel (< ${{ env.PERFORMANCE_THRESHOLD }}ms)"
        else
          echo "âš ï¸ Performance acima do limite esperado (${response_time}ms > ${{ env.PERFORMANCE_THRESHOLD }}ms)"
        fi
        
        # Teste de mÃºltiplas requisiÃ§Ãµes simultÃ¢neas
        echo "ğŸ”„ Testando carga com mÃºltiplas requisiÃ§Ãµes..."
        for i in {1..5}; do
          curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null &
        done
        wait
        echo "âœ… Teste de carga bÃ¡sico concluÃ­do"
    
    - name: Test 3 - Estabilidade da AplicaÃ§Ã£o
      run: |
        echo "ğŸ›¡ï¸ Testando estabilidade da aplicaÃ§Ã£o..."
        
        # Teste de estabilidade com requisiÃ§Ãµes contÃ­nuas
        echo "ğŸ”„ Executando teste de estabilidade (30 requisiÃ§Ãµes em 30 segundos)..."
        success_count=0
        total_requests=30
        
        for i in $(seq 1 $total_requests); do
          if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
            success_count=$((success_count + 1))
          fi
          sleep 1
        done
        
        success_rate=$((success_count * 100 / total_requests))
        echo "ğŸ“Š Taxa de sucesso: ${success_rate}% (${success_count}/${total_requests})"
        
        if [ "$success_rate" -ge "95" ]; then
          echo "âœ… AplicaÃ§Ã£o demonstrou alta estabilidade (â‰¥95%)"
        elif [ "$success_rate" -ge "90" ]; then
          echo "âš ï¸ AplicaÃ§Ã£o demonstrou estabilidade aceitÃ¡vel (â‰¥90%)"
        else
          echo "âŒ AplicaÃ§Ã£o demonstrou baixa estabilidade (<90%)"
          exit 1
        fi
        
        # VerificaÃ§Ã£o de logs de erro
        echo "ğŸ“‹ Verificando logs para erros crÃ­ticos..."
        # Note: Este comando pode precisar ser ajustado baseado na configuraÃ§Ã£o real do servidor
        # ssh ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }} "docker logs ${{ env.CONTAINER_NAME }} --tail=50" | grep -i "error\|exception\|fatal" || echo "âœ… Nenhum erro crÃ­tico encontrado nos logs recentes"

  # Job de monitoramento pÃ³s-deploy
  post-deploy-monitoring:
    needs: [deploy, production-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Monitor Application Health
      run: |
        echo "ğŸ“Š Iniciando monitoramento pÃ³s-deploy..."
        
        # Monitoramento por 5 minutos
        monitor_duration=300  # 5 minutos
        check_interval=30     # 30 segundos
        checks_count=$((monitor_duration / check_interval))
        
        echo "ğŸ” Executando $checks_count verificaÃ§Ãµes de saÃºde em $monitor_duration segundos..."
        
        failed_checks=0
        for i in $(seq 1 $checks_count); do
          echo "ğŸ“‹ VerificaÃ§Ã£o $i/$checks_count..."
          
          if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
            echo "âœ… Check $i: OK"
          else
            echo "âŒ Check $i: FALHOU"
            failed_checks=$((failed_checks + 1))
          fi
          
          if [ $i -lt $checks_count ]; then
            sleep $check_interval
          fi
        done
        
        # AnÃ¡lise dos resultados
        success_rate=$(((checks_count - failed_checks) * 100 / checks_count))
        echo "ğŸ“Š Resultado do monitoramento:"
        echo "   - VerificaÃ§Ãµes totais: $checks_count"
        echo "   - VerificaÃ§Ãµes com sucesso: $((checks_count - failed_checks))"
        echo "   - VerificaÃ§Ãµes falharam: $failed_checks"
        echo "   - Taxa de sucesso: ${success_rate}%"
        
        if [ "$success_rate" -ge "95" ]; then
          echo "âœ… Sistema demonstrou excelente estabilidade pÃ³s-deploy"
        elif [ "$success_rate" -ge "90" ]; then
          echo "âš ï¸ Sistema demonstrou boa estabilidade pÃ³s-deploy"
        else
          echo "âŒ Sistema demonstrou problemas de estabilidade pÃ³s-deploy"
          echo "ğŸš¨ Recomenda-se investigaÃ§Ã£o imediata"
        fi
    
    - name: Generate Deployment Report
      run: |
        echo "ğŸ“„ Gerando relatÃ³rio de deploy..."
        
        # Criar relatÃ³rio em markdown
        cat > deployment-report.md << EOF
        # ğŸ“‹ RelatÃ³rio de Deploy - Barbear.IA
        
        **Data/Hora:** $(date '+%Y-%m-%d %H:%M:%S UTC')
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        **Workflow:** ${{ github.run_id }}
        
        ## âœ… Etapas ConcluÃ­das
        
        ### ğŸ§¹ Limpeza de Cache
        - âœ… Cache do Docker limpo completamente
        - âœ… Cache do Nginx limpo
        - âœ… Cache do Frontend limpo
        
        ### ğŸ”„ ReinicializaÃ§Ã£o de ServiÃ§os
        - âœ… Container principal reiniciado
        - âœ… Nginx reiniciado
        - âœ… ServiÃ§os auxiliares verificados
        
        ### ğŸ§ª Testes Automatizados
        - âœ… Teste de funcionamento dos logins
        - âœ… Teste de performance do sistema
        - âœ… Teste de estabilidade da aplicaÃ§Ã£o
        
        ### ğŸ“Š Monitoramento PÃ³s-Deploy
        - âœ… Monitoramento de 5 minutos executado
        - âœ… VerificaÃ§Ãµes de saÃºde realizadas
        
        ## ğŸŒ InformaÃ§Ãµes de Acesso
        
        **URL da AplicaÃ§Ã£o:** http://${{ secrets.OCI_HOST }}:${{ env.PORT }}
        **Status:** âœ… Online e Funcionando
        
        ## ğŸ“ˆ MÃ©tricas de Performance
        
        - **Tempo de Build:** Verificar logs do workflow
        - **Tempo de Deploy:** Verificar logs do workflow
        - **Taxa de Sucesso dos Testes:** â‰¥95% (conforme logs)
        
        ## ğŸ” PrÃ³ximos Passos Recomendados
        
        1. Monitorar logs da aplicaÃ§Ã£o nas prÃ³ximas 24 horas
        2. Verificar mÃ©tricas de uso e performance
        3. Validar funcionalidades crÃ­ticas manualmente se necessÃ¡rio
        4. Documentar qualquer comportamento anÃ´malo observado
        
        ---
        *RelatÃ³rio gerado automaticamente pelo GitHub Actions*
        EOF
        
        echo "âœ… RelatÃ³rio de deploy gerado com sucesso"
        cat deployment-report.md
    
    - name: Upload Deployment Report
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report-${{ github.run_id }}
        path: deployment-report.md
        retention-days: 30