name: üöÄ Deploy Barbear.IA para OCI - Rebuild Completo

on:
  push:
    branches: [ main ]  # Trigger autom√°tico no push para main
  workflow_dispatch:    # Permite execu√ß√£o manual
    inputs:
      force_rebuild:
        description: 'For√ßar rebuild completo (remove todos containers/imagens)'
        required: false
        default: 'true'
        type: boolean
      skip_tests:
        description: 'Pular testes (apenas para emerg√™ncias)'
        required: false
        default: 'false'
        type: boolean
  schedule:
    - cron: '0 2 * * 0'  # Deploy semanal de manuten√ß√£o (Domingo 2h)

# Controle de concorr√™ncia para evitar deployments paralelos
concurrency:
  group: deploy-barbear-ia-${{ github.ref }}
  cancel-in-progress: true

env:
  PROJECT_NAME: "Barbear.IA"
  CONTAINER_NAME: "barbear-ia-frontend"
  PORT: 3500
  NGINX_CONTAINER: "nginx-proxy"
  HEALTH_CHECK_TIMEOUT: 300
  PERFORMANCE_THRESHOLD: 3000
  DEPLOY_TIMEOUT: 1800  # 30 minutos timeout para opera√ß√µes cr√≠ticas
  ROLLBACK_ENABLED: true
  LOG_LEVEL: "INFO"

jobs:
  # Job de valida√ß√£o de integridade e prepara√ß√£o
  integrity-check:
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.commit-info.outputs.sha }}
      commit_short: ${{ steps.commit-info.outputs.short }}
      source_checksum: ${{ steps.checksum.outputs.checksum }}
      timestamp: ${{ steps.timestamp.outputs.timestamp }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch completo para valida√ß√£o de hist√≥rico
    
    - name: üìä Capturar informa√ß√µes do commit
      id: commit-info
      run: |
        echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "short=$(echo ${{ github.sha }} | cut -c1-8)" >> $GITHUB_OUTPUT
        echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        echo "author=${{ github.actor }}" >> $GITHUB_OUTPUT
        
    - name: üîê Gerar checksum SHA-256 dos arquivos cr√≠ticos
      id: checksum
      run: |
        echo "üîç Gerando checksums dos arquivos cr√≠ticos..."
        
        # Lista de arquivos cr√≠ticos para verifica√ß√£o de integridade
        CRITICAL_FILES=(
          "package.json"
          "package-lock.json"
          "Dockerfile"
          "docker-compose.yml"
          "nginx.conf"
          "vite.config.ts"
          "tsconfig.json"
          "src/main.tsx"
          "src/App.tsx"
        )
        
        # Gerar checksum combinado
        COMBINED_HASH=""
        for file in "${CRITICAL_FILES[@]}"; do
          if [ -f "$file" ]; then
            file_hash=$(sha256sum "$file" | cut -d' ' -f1)
            echo "‚úÖ $file: $file_hash"
            COMBINED_HASH="${COMBINED_HASH}${file_hash}"
          else
            echo "‚ö†Ô∏è Arquivo n√£o encontrado: $file"
          fi
        done
        
        # Checksum final
        FINAL_CHECKSUM=$(echo -n "$COMBINED_HASH" | sha256sum | cut -d' ' -f1)
        echo "üîê Checksum final: $FINAL_CHECKSUM"
        echo "checksum=$FINAL_CHECKSUM" >> $GITHUB_OUTPUT
        
        # Salvar checksums individuais
        echo "üìù Salvando checksums individuais..."
        mkdir -p checksums
        for file in "${CRITICAL_FILES[@]}"; do
          if [ -f "$file" ]; then
            sha256sum "$file" >> checksums/files.sha256
          fi
        done
        
    - name: ‚è∞ Timestamp de deploy
      id: timestamp
      run: |
        TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
        echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
        echo "üïê Timestamp: $TIMESTAMP"
        
    - name: üì§ Upload checksums como artefato
      uses: actions/upload-artifact@v4
      with:
        name: integrity-checksums-${{ steps.commit-info.outputs.short }}
        path: checksums/
        retention-days: 30

  test:
    needs: integrity-check
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        # Removido cache: 'npm' para for√ßar instala√ß√£o limpa
    
    - name: Clean npm cache
      run: |
        npm cache clean --force
        npm cache verify
    
    - name: Install dependencies (clean)
      run: |
        rm -rf node_modules package-lock.json
        npm install --no-audit --no-fund
    
    - name: Clean Vite cache
      run: |
        rm -rf node_modules/.vite
        rm -rf dist
        rm -rf build
    
    - name: Run linting
      run: npm run lint || echo "Linting completed with warnings"
    
    - name: Run tests
      run: npm test -- --coverage --watchAll=false
    
    - name: Build application (force clean & debug)
      run: |
        echo "=== Node / npm versions ==="
        node -v
        npm -v
        echo "=== Listing project files ==="
        ls -la
        echo "=== Running Vite build with DEBUG=vite:* ==="
        export DEBUG=vite:*
        # executar build e, em caso de falha, imprimir arquivos de configura√ß√£o relevantes
        if npm run build; then
          echo "‚úÖ Build conclu√≠do com sucesso"
        else
          echo "‚ùå Build falhou ‚Äî exibindo debug"
          echo "--- package.json ---"
          cat package.json || true
          echo "--- vite.config.* ---"
          ls -la vite.config.* || true
          cat vite.config.ts || true
          echo "--- tsconfig.json ---"
          cat tsconfig.json || true
          echo "--- √öltimos arquivos de log / npm list ---"
          npm ls --depth=0 || true
          echo "--- Verificando node_modules ---"
          ls -la node_modules/@vitejs/ || true
          echo "--- Finalizando com exit 1 ---"
          exit 1
        fi
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-files
        path: build/
        retention-days: 1

  deploy:
    needs: [integrity-check, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (success() || inputs.skip_tests)
    timeout-minutes: 30  # Timeout de 30 minutos para deploy
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: üì• Download checksums de integridade
      uses: actions/download-artifact@v4
      with:
        name: integrity-checksums-${{ needs.integrity-check.outputs.commit_short }}
        path: checksums/
    
    - name: üîê Preparar autentica√ß√£o SSH segura
      run: |
        echo "üîë Configurando autentica√ß√£o SSH..."
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar known_hosts para evitar prompt de verifica√ß√£o
        echo "${{ secrets.OCI_HOST_KEY }}" >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts
        
        # Validar conectividade SSH
        echo "üîç Testando conectividade SSH..."
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=yes ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }} "echo 'SSH conectado com sucesso'"

    - name: üßπ Limpeza completa e remo√ß√£o for√ßada de containers
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 600s  # 10 minutos timeout
        script: |
          set -e  # Parar em caso de erro
          
          echo "üöÄ Iniciando limpeza completa do ${{ env.PROJECT_NAME }}..."
          echo "üìä Commit: ${{ needs.integrity-check.outputs.commit_short }}"
          echo "üîê Checksum: ${{ needs.integrity-check.outputs.source_checksum }}"
          echo "‚è∞ Timestamp: ${{ needs.integrity-check.outputs.timestamp }}"
          
          # Criar diret√≥rio do projeto
          sudo mkdir -p /var/www/${{ env.PROJECT_NAME }}
          sudo chown ${{ secrets.OCI_USERNAME }}:${{ secrets.OCI_USERNAME }} /var/www/${{ env.PROJECT_NAME }}
          cd /var/www/${{ env.PROJECT_NAME }}
          
          # Criar snapshot de backup antes da limpeza
          echo "üì¶ Criando snapshot de backup..."
          BACKUP_DIR="/var/backups/barbear-ia-snapshots"
          sudo mkdir -p "$BACKUP_DIR"
          BACKUP_NAME="backup-${{ needs.integrity-check.outputs.timestamp }}-${{ needs.integrity-check.outputs.commit_short }}"
          
          # Backup de configura√ß√µes cr√≠ticas
          if [ -f docker-compose.yml ]; then
            sudo cp docker-compose.yml "$BACKUP_DIR/$BACKUP_NAME-docker-compose.yml"
          fi
          
          if [ -f nginx.conf ]; then
            sudo cp nginx.conf "$BACKUP_DIR/$BACKUP_NAME-nginx.conf"
          fi
          
          # Backup de dados de volumes (se existirem)
          if docker volume ls | grep -q barbear; then
            echo "üíæ Fazendo backup de volumes..."
            docker run --rm -v barbear-ia-data:/data -v "$BACKUP_DIR":/backup alpine tar czf "/backup/$BACKUP_NAME-volumes.tar.gz" -C /data . || true
          fi
          
          echo "‚úÖ Backup criado: $BACKUP_NAME"
          
          # REMO√á√ÉO FOR√áADA COMPLETA
          echo "üßπ Iniciando remo√ß√£o for√ßada completa..."
          
          # Parar todos os containers relacionados
          echo "üõë Parando containers relacionados ao Barbear.IA..."
          docker ps -a --filter "name=barbear" --format "{{.Names}}" | xargs -r docker stop || true
          docker ps -a --filter "name=${{ env.CONTAINER_NAME }}" --format "{{.Names}}" | xargs -r docker stop || true
          
          # Remover containers for√ßadamente
          echo "üóëÔ∏è Removendo containers for√ßadamente..."
          docker ps -a --filter "name=barbear" --format "{{.Names}}" | xargs -r docker rm -f || true
          docker ps -a --filter "name=${{ env.CONTAINER_NAME }}" --format "{{.Names}}" | xargs -r docker rm -f || true
          
          # Remover imagens relacionadas
          echo "üóëÔ∏è Removendo imagens relacionadas..."
          docker images --filter "reference=*barbear*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi -f || true
          docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.Repository}}:{{.Tag}}" | xargs -r docker rmi -f || true
          
          # Limpeza completa do sistema Docker
          echo "üßπ Limpeza completa do sistema Docker..."
          docker system prune -a -f --volumes || true
          docker builder prune -a -f || true
          docker volume prune -f || true
          docker network prune -f || true
          
          # Limpeza de cache do sistema
          echo "üßπ Limpeza de cache do sistema..."
          sudo rm -rf /tmp/barbear-* || true
          sudo rm -rf /var/cache/barbear-* || true
          sudo find /tmp -name "*barbear*" -type f -delete || true
          
          # Verificar se limpeza foi bem-sucedida
          echo "üîç Verificando limpeza..."
          REMAINING_CONTAINERS=$(docker ps -a --filter "name=barbear" --format "{{.Names}}" | wc -l)
          REMAINING_IMAGES=$(docker images --filter "reference=*barbear*" --format "{{.Repository}}" | wc -l)
          
          if [ "$REMAINING_CONTAINERS" -eq 0 ] && [ "$REMAINING_IMAGES" -eq 0 ]; then
            echo "‚úÖ Limpeza completa realizada com sucesso"
          else
            echo "‚ö†Ô∏è Alguns artefatos podem ter permanecido:"
            echo "   Containers: $REMAINING_CONTAINERS"
            echo "   Imagens: $REMAINING_IMAGES"
          fi
          
          echo "üéØ Limpeza completa finalizada"
    
    - name: üì• Sincroniza√ß√£o segura de arquivos do reposit√≥rio
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 300s  # 5 minutos timeout
        script: |
          set -e
          
          echo "üöÄ Iniciando sincroniza√ß√£o segura do ${{ env.PROJECT_NAME }}..."
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          # Validar integridade do reposit√≥rio remoto
          echo "üîç Validando integridade do reposit√≥rio..."
          
          # Function to download file with checksum validation
          download_and_validate() {
            local file=$1
            local expected_checksum=$2
            
            echo "üì• Baixando $file..."
            if curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                    -H "Accept: application/vnd.github.v3.raw" \
                    -o "$file.tmp" \
                    -L "https://api.github.com/repos/${{ github.repository }}/contents/$file?ref=${{ github.sha }}" \
                    --fail --silent --show-error; then
              
              # Validar checksum se fornecido
              if [ ! -z "$expected_checksum" ]; then
                actual_checksum=$(sha256sum "$file.tmp" | cut -d' ' -f1)
                if [ "$actual_checksum" != "$expected_checksum" ]; then
                  echo "‚ùå Checksum inv√°lido para $file"
                  echo "   Esperado: $expected_checksum"
                  echo "   Atual: $actual_checksum"
                  rm -f "$file.tmp"
                  return 1
                fi
              fi
              
              mv "$file.tmp" "$file"
              echo "‚úÖ $file baixado e validado com sucesso"
              return 0
            else
              echo "‚ùå Erro ao baixar $file"
              rm -f "$file.tmp"
              return 1
            fi
          }
          
          # Download arquivos cr√≠ticos com valida√ß√£o
          echo "üì¶ Baixando arquivos cr√≠ticos..."
          
          download_and_validate "docker-compose.yml"
          download_and_validate "Dockerfile"
          download_and_validate "nginx.conf"
          download_and_validate "package.json"
          download_and_validate "package-lock.json"
          download_and_validate ".dockerignore"
          download_and_validate "vite.config.ts"
          download_and_validate "tsconfig.json"
          
          # Validar commit espec√≠fico
          echo "üîç Validando commit espec√≠fico..."
          REMOTE_COMMIT=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                              -H "Accept: application/vnd.github.v3+json" \
                              -s "https://api.github.com/repos/${{ github.repository }}/commits/${{ github.sha }}" \
                              | grep '"sha"' | head -1 | cut -d'"' -f4)
          
          if [ "$REMOTE_COMMIT" = "${{ github.sha }}" ]; then
            echo "‚úÖ Commit validado: ${{ needs.integrity-check.outputs.commit_short }}"
          else
            echo "‚ùå Commit n√£o corresponde ao esperado"
            echo "   Esperado: ${{ github.sha }}"
            echo "   Remoto: $REMOTE_COMMIT"
            exit 1
          fi
          
          # Criar arquivo de metadados do deploy
          echo "üìù Criando metadados do deploy..."
          cat > deploy-metadata.json << EOF
          {
            "commit_sha": "${{ github.sha }}",
            "commit_short": "${{ needs.integrity-check.outputs.commit_short }}",
            "source_checksum": "${{ needs.integrity-check.outputs.source_checksum }}",
            "deploy_timestamp": "${{ needs.integrity-check.outputs.timestamp }}",
            "branch": "${{ github.ref_name }}",
            "author": "${{ github.actor }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}"
          }
          EOF
          
          echo "‚úÖ Sincroniza√ß√£o de arquivos conclu√≠da com valida√ß√£o de integridade"

    - name: üèóÔ∏è Build e Deploy Completo com Verifica√ß√µes Robustas
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        timeout: 1200s  # 20 minutos timeout para build completo
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "üîÑ Iniciando build e deploy completo do ${{ env.PROJECT_NAME }}..."
          echo "üìä Metadados do deploy:"
          cat deploy-metadata.json | jq '.' || cat deploy-metadata.json
          
          # Verificar pr√©-requisitos
          echo "üîç Verificando pr√©-requisitos..."
          
          # Verificar se Docker est√° funcionando
          if ! docker --version > /dev/null 2>&1; then
            echo "‚ùå Docker n√£o est√° dispon√≠vel"
            exit 1
          fi
          
          # Verificar se docker-compose est√° dispon√≠vel
          if ! docker-compose --version > /dev/null 2>&1; then
            echo "‚ùå Docker Compose n√£o est√° dispon√≠vel"
            exit 1
          fi
          
          # Verificar espa√ßo em disco
          AVAILABLE_SPACE=$(df /var/www | tail -1 | awk '{print $4}')
          MIN_SPACE=2097152  # 2GB em KB
          
          if [ "$AVAILABLE_SPACE" -lt "$MIN_SPACE" ]; then
            echo "‚ùå Espa√ßo em disco insuficiente"
            echo "   Dispon√≠vel: ${AVAILABLE_SPACE}KB"
            echo "   M√≠nimo: ${MIN_SPACE}KB"
            exit 1
          fi
          
          echo "‚úÖ Pr√©-requisitos verificados"
          
          # Build da nova imagem com logs detalhados
          echo "üèóÔ∏è Construindo nova imagem (build completo sem cache)..."
          
          # Definir vari√°veis de build
          BUILD_ARGS="--build-arg COMMIT_SHA=${{ github.sha }} \
                      --build-arg BUILD_TIMESTAMP=${{ needs.integrity-check.outputs.timestamp }} \
                      --build-arg SOURCE_CHECKSUM=${{ needs.integrity-check.outputs.source_checksum }}"
          
          # Build com logs detalhados e sem cache
          echo "üî® Executando docker-compose build..."
          if docker-compose build --no-cache --pull --force-rm --progress=plain $BUILD_ARGS ${{ env.CONTAINER_NAME }} 2>&1 | tee build.log; then
            echo "‚úÖ Build conclu√≠do com sucesso"
            
            # Verificar se a imagem foi criada
            NEW_IMAGE_ID=$(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.ID}}" | head -1)
            if [ -z "$NEW_IMAGE_ID" ]; then
              echo "‚ùå Imagem n√£o foi criada corretamente"
              exit 1
            fi
            
            echo "‚úÖ Nova imagem criada: $NEW_IMAGE_ID"
            
          else
            echo "‚ùå Erro no build da imagem"
            echo "üìã √öltimas linhas do log de build:"
            tail -20 build.log || true
            exit 1
          fi
          
          # Verifica√ß√£o de sa√∫de da imagem
          echo "üîç Verificando sa√∫de da nova imagem..."
          
          # Testar a imagem antes do deploy
          TEST_CONTAINER="test-${{ env.CONTAINER_NAME }}-${{ needs.integrity-check.outputs.commit_short }}"
          
          echo "üß™ Iniciando container de teste..."
          if docker run -d --name "$TEST_CONTAINER" -p 8080:80 --health-interval=10s --health-timeout=5s --health-retries=3 "${{ env.CONTAINER_NAME }}:latest"; then
            
            # Aguardar container ficar saud√°vel
            echo "‚è≥ Aguardando container de teste ficar saud√°vel..."
            HEALTH_RETRIES=0
            MAX_HEALTH_RETRIES=12  # 2 minutos
            
            while [ $HEALTH_RETRIES -lt $MAX_HEALTH_RETRIES ]; do
              HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' "$TEST_CONTAINER" 2>/dev/null || echo "unknown")
              
              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "‚úÖ Container de teste est√° saud√°vel"
                break
              elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
                echo "‚ùå Container de teste n√£o est√° saud√°vel"
                docker logs "$TEST_CONTAINER" | tail -20
                docker rm -f "$TEST_CONTAINER" || true
                exit 1
              else
                echo "‚è≥ Status: $HEALTH_STATUS (tentativa $((HEALTH_RETRIES + 1))/$MAX_HEALTH_RETRIES)"
                sleep 10
                HEALTH_RETRIES=$((HEALTH_RETRIES + 1))
              fi
            done
            
            if [ $HEALTH_RETRIES -eq $MAX_HEALTH_RETRIES ]; then
              echo "‚ùå Timeout na verifica√ß√£o de sa√∫de do container de teste"
              docker logs "$TEST_CONTAINER" | tail -20
              docker rm -f "$TEST_CONTAINER" || true
              exit 1
            fi
            
            # Teste de conectividade HTTP
            echo "üåê Testando conectividade HTTP..."
            if curl -f -s http://localhost:8080/ > /dev/null; then
              echo "‚úÖ Teste HTTP passou"
            else
              echo "‚ùå Teste HTTP falhou"
              docker logs "$TEST_CONTAINER" | tail -20
              docker rm -f "$TEST_CONTAINER" || true
              exit 1
            fi
            
            # Limpar container de teste
            docker rm -f "$TEST_CONTAINER" || true
            echo "‚úÖ Verifica√ß√£o de sa√∫de da imagem conclu√≠da"
            
          else
            echo "‚ùå Falha ao iniciar container de teste"
            exit 1
          fi
          
          # Deploy da nova vers√£o
          echo "üöÄ Iniciando deploy da nova vers√£o..."
          
          # Parar vers√£o atual se existir
          echo "üõë Parando vers√£o atual..."
          docker-compose down --remove-orphans || true
          
          # Iniciar nova vers√£o
          echo "üöÄ Iniciando nova vers√£o..."
          if docker-compose up -d ${{ env.CONTAINER_NAME }}; then
            echo "‚úÖ Nova vers√£o iniciada"
          else
            echo "‚ùå Falha ao iniciar nova vers√£o"
            echo "üìã Logs do docker-compose:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi
          
          # Aguardar inicializa√ß√£o
          echo "‚è≥ Aguardando inicializa√ß√£o completa (45 segundos)..."
          sleep 45
          
          # Verifica√ß√£o de sa√∫de p√≥s-deploy
          echo "üîç Executando verifica√ß√£o de sa√∫de p√≥s-deploy..."
          
          HEALTH_CHECK_RETRIES=0
          MAX_HEALTH_CHECK_RETRIES=10
          
          while [ $HEALTH_CHECK_RETRIES -lt $MAX_HEALTH_CHECK_RETRIES ]; do
            if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
              echo "‚úÖ Verifica√ß√£o de sa√∫de passou!"
              
              # Verificar se o container est√° realmente rodando
              if docker-compose ps ${{ env.CONTAINER_NAME }} | grep -q "Up"; then
                echo "‚úÖ Container est√° rodando corretamente"
                break
              else
                echo "‚ùå Container n√£o est√° no estado 'Up'"
                docker-compose ps
                exit 1
              fi
              
            else
              HEALTH_CHECK_RETRIES=$((HEALTH_CHECK_RETRIES + 1))
              echo "‚è≥ Verifica√ß√£o de sa√∫de falhou (tentativa $HEALTH_CHECK_RETRIES/$MAX_HEALTH_CHECK_RETRIES)"
              
              if [ $HEALTH_CHECK_RETRIES -lt $MAX_HEALTH_CHECK_RETRIES ]; then
                echo "‚è≥ Aguardando 15 segundos antes da pr√≥xima tentativa..."
                sleep 15
              fi
            fi
          done
          
          # Verifica√ß√£o final
          if [ $HEALTH_CHECK_RETRIES -eq $MAX_HEALTH_CHECK_RETRIES ]; then
            echo "‚ùå Verifica√ß√£o de sa√∫de falhou ap√≥s $MAX_HEALTH_CHECK_RETRIES tentativas"
            echo "üìã Logs do container:"
            docker-compose logs --tail=30 ${{ env.CONTAINER_NAME }}
            echo "üìä Status dos containers:"
            docker-compose ps
            
            # Tentar rollback autom√°tico se habilitado
            if [ "${{ env.ROLLBACK_ENABLED }}" = "true" ]; then
              echo "üîÑ Iniciando rollback autom√°tico..."
              
              # Procurar backup mais recente
              LATEST_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-docker-compose.yml 2>/dev/null | head -1)
              
              if [ ! -z "$LATEST_BACKUP" ] && [ -f "$LATEST_BACKUP" ]; then
                echo "üì¶ Restaurando backup: $(basename $LATEST_BACKUP)"
                cp "$LATEST_BACKUP" docker-compose.yml
                
                docker-compose down || true
                docker-compose up -d ${{ env.CONTAINER_NAME }}
                sleep 30
                
                if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
                  echo "‚úÖ Rollback realizado com sucesso"
                  echo "‚ö†Ô∏è Deploy falhou, mas sistema foi restaurado para vers√£o anterior"
                  exit 1  # Ainda √© uma falha, mas sistema est√° funcionando
                else
                  echo "‚ùå Rollback tamb√©m falhou"
                  exit 1
                fi
              else
                echo "‚ùå Nenhum backup dispon√≠vel para rollback"
                exit 1
              fi
            else
              exit 1
            fi
          fi
          
          # Limpeza p√≥s-deploy
          echo "üßπ Limpeza p√≥s-deploy..."
          docker image prune -f || true
          
          # Salvar informa√ß√µes do deploy bem-sucedido
          echo "üìù Salvando informa√ß√µes do deploy..."
          cat > last-successful-deploy.json << EOF
          {
            "commit_sha": "${{ github.sha }}",
            "commit_short": "${{ needs.integrity-check.outputs.commit_short }}",
            "deploy_timestamp": "${{ needs.integrity-check.outputs.timestamp }}",
            "image_id": "$(docker images --filter 'reference=*${{ env.CONTAINER_NAME }}*' --format '{{.ID}}' | head -1)",
            "container_id": "$(docker-compose ps -q ${{ env.CONTAINER_NAME }})",
            "success": true
          }
          EOF
          
          echo "üéâ Deploy do ${{ env.PROJECT_NAME }} realizado com sucesso!"
          echo "üåê Aplica√ß√£o dispon√≠vel em: http://${{ secrets.OCI_HOST }}:${{ env.PORT }}"
          echo "üìä Commit: ${{ needs.integrity-check.outputs.commit_short }}"
          echo "üîê Checksum: ${{ needs.integrity-check.outputs.source_checksum }}"

    - name: üßπ Limpeza Final e Verifica√ß√£o de Integridade
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "üßπ Executando limpeza final e verifica√ß√£o de integridade..."
          
          # Limpeza de imagens n√£o utilizadas (manter apenas as 3 mais recentes)
          echo "üóëÔ∏è Limpeza de imagens antigas..."
          
          # Listar imagens do projeto e manter apenas as 3 mais recentes
          IMAGES_TO_REMOVE=$(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" --format "{{.ID}} {{.CreatedAt}}" | sort -k2 -r | tail -n +4 | awk '{print $1}')
          
          if [ ! -z "$IMAGES_TO_REMOVE" ]; then
            echo "üóëÔ∏è Removendo imagens antigas:"
            echo "$IMAGES_TO_REMOVE"
            echo "$IMAGES_TO_REMOVE" | xargs -r docker rmi -f || true
          else
            echo "‚úÖ Nenhuma imagem antiga para remover"
          fi
          
          # Limpeza geral do sistema Docker (sem afetar outros projetos)
          echo "üßπ Limpeza geral do Docker..."
          docker system prune -f --filter "until=24h" || true
          
          # Verifica√ß√£o final de integridade
          echo "üîç Verifica√ß√£o final de integridade..."
          
          # Verificar se o container est√° rodando
          CONTAINER_STATUS=$(docker-compose ps ${{ env.CONTAINER_NAME }} --format "{{.Status}}" 2>/dev/null || echo "not found")
          
          if echo "$CONTAINER_STATUS" | grep -q "Up"; then
            echo "‚úÖ Container est√° rodando: $CONTAINER_STATUS"
          else
            echo "‚ùå Container n√£o est√° rodando: $CONTAINER_STATUS"
            exit 1
          fi
          
          # Verificar conectividade HTTP final
          echo "üåê Verifica√ß√£o HTTP final..."
          if curl -f -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ | grep -q "200"; then
            echo "‚úÖ Aplica√ß√£o respondendo corretamente (HTTP 200)"
          else
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ || echo "000")
            echo "‚ùå Aplica√ß√£o n√£o est√° respondendo corretamente (HTTP $HTTP_CODE)"
            exit 1
          fi
          
          # Verificar logs por erros cr√≠ticos
          echo "üìã Verificando logs por erros cr√≠ticos..."
          CRITICAL_ERRORS=$(docker-compose logs --tail=50 ${{ env.CONTAINER_NAME }} 2>&1 | grep -i "error\|fatal\|exception" | wc -l)
          
          if [ "$CRITICAL_ERRORS" -gt 0 ]; then
            echo "‚ö†Ô∏è Encontrados $CRITICAL_ERRORS erros cr√≠ticos nos logs:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} | grep -i "error\|fatal\|exception" || true
            echo "‚ö†Ô∏è Deploy conclu√≠do, mas com erros nos logs"
          else
            echo "‚úÖ Nenhum erro cr√≠tico encontrado nos logs"
          fi
          
          # Salvar estat√≠sticas do deploy
          echo "üìä Salvando estat√≠sticas do deploy..."
          cat > deploy-stats.json << EOF
          {
            "deploy_completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "container_status": "$CONTAINER_STATUS",
            "http_status": "$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.PORT }}/ || echo "000")",
            "critical_errors_count": $CRITICAL_ERRORS,
            "disk_usage": "$(df /var/www | tail -1 | awk '{print $5}')",
            "docker_images_count": $(docker images --filter "reference=*${{ env.CONTAINER_NAME }}*" | wc -l),
            "memory_usage": "$(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')"
          }
          EOF
          
          echo "‚úÖ Limpeza final conclu√≠da"

  # Job de rollback autom√°tico (executado apenas em caso de falha)
  rollback:
    name: üîÑ Rollback Autom√°tico
    runs-on: ubuntu-latest
    needs: [integrity-check, test, deploy]
    if: failure() && needs.deploy.result == 'failure' && env.ROLLBACK_ENABLED == 'true'
    timeout-minutes: 15
    
    steps:
    - name: üîÑ Executar Rollback Autom√°tico
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.OCI_HOST }}
        username: ${{ secrets.OCI_USERNAME }}
        key: ${{ secrets.OCI_SSH_KEY }}
        script: |
          set -e
          
          cd /var/www/${{ env.PROJECT_NAME }}
          
          echo "üîÑ Iniciando rollback autom√°tico devido a falha no deploy..."
          
          # Procurar backup mais recente
          LATEST_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-docker-compose.yml 2>/dev/null | head -1)
          LATEST_IMAGE_BACKUP=$(ls -t /var/backups/barbear-ia-snapshots/backup-*-image.tar 2>/dev/null | head -1)
          
          if [ -z "$LATEST_BACKUP" ]; then
            echo "‚ùå Nenhum backup de configura√ß√£o encontrado"
            exit 1
          fi
          
          echo "üì¶ Restaurando backup de configura√ß√£o: $(basename $LATEST_BACKUP)"
          cp "$LATEST_BACKUP" docker-compose.yml
          
          # Restaurar imagem se dispon√≠vel
          if [ ! -z "$LATEST_IMAGE_BACKUP" ] && [ -f "$LATEST_IMAGE_BACKUP" ]; then
            echo "üì¶ Restaurando imagem de backup: $(basename $LATEST_IMAGE_BACKUP)"
            docker load -i "$LATEST_IMAGE_BACKUP"
          fi
          
          # Parar containers atuais
          echo "üõë Parando containers atuais..."
          docker-compose down --remove-orphans || true
          
          # Iniciar vers√£o de backup
          echo "üöÄ Iniciando vers√£o de backup..."
          docker-compose up -d ${{ env.CONTAINER_NAME }}
          
          # Aguardar inicializa√ß√£o
          echo "‚è≥ Aguardando inicializa√ß√£o (30 segundos)..."
          sleep 30
          
          # Verificar se rollback foi bem-sucedido
          ROLLBACK_RETRIES=0
          MAX_ROLLBACK_RETRIES=5
          
          while [ $ROLLBACK_RETRIES -lt $MAX_ROLLBACK_RETRIES ]; do
            if curl -f -s http://localhost:${{ env.PORT }}/ > /dev/null; then
              echo "‚úÖ Rollback realizado com sucesso!"
              
              # Salvar informa√ß√µes do rollback
              cat > rollback-info.json << EOF
              {
                "rollback_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "failed_commit": "${{ github.sha }}",
                "restored_backup": "$(basename $LATEST_BACKUP)",
                "success": true
              }
              EOF
              
              echo "üìù Informa√ß√µes do rollback salvas"
              break
            else
              ROLLBACK_RETRIES=$((ROLLBACK_RETRIES + 1))
              echo "‚è≥ Rollback tentativa $ROLLBACK_RETRIES/$MAX_ROLLBACK_RETRIES falhou"
              
              if [ $ROLLBACK_RETRIES -lt $MAX_ROLLBACK_RETRIES ]; then
                sleep 10
              fi
            fi
          done
          
          if [ $ROLLBACK_RETRIES -eq $MAX_ROLLBACK_RETRIES ]; then
            echo "‚ùå Rollback falhou ap√≥s $MAX_ROLLBACK_RETRIES tentativas"
            echo "üìã Logs do container:"
            docker-compose logs --tail=20 ${{ env.CONTAINER_NAME }} || true
            exit 1
          fi

    - name: üìß Notificar Rollback
      if: success()
      run: |
        echo "üîÑ Rollback autom√°tico executado com sucesso"
        echo "‚ö†Ô∏è Deploy do commit ${{ github.sha }} falhou e foi revertido"
        echo "üìä Aplica√ß√£o restaurada para vers√£o anterior"
        # Aqui voc√™ pode adicionar notifica√ß√µes por email, Slack, etc.

  # Job de testes automatizados em produ√ß√£o
  production-tests:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Node.js for testing
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install testing dependencies
      run: |
        npm install --only=dev
        npm install playwright @playwright/test
    
    - name: Wait for application to be fully ready
      run: |
        echo "‚è≥ Aguardando aplica√ß√£o estar completamente pronta..."
        sleep 60
    
    - name: Test 1 - Funcionamento dos Logins
      run: |
        echo "üîê Testando funcionamento dos logins..."
        
        # Teste de conectividade b√°sica
        if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
          echo "‚úÖ Aplica√ß√£o est√° respondendo"
        else
          echo "‚ùå Aplica√ß√£o n√£o est√° respondendo"
          exit 1
        fi
        
        # Teste de carregamento da p√°gina de login
        response=$(curl -s -o /dev/null -w "%{http_code}" "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/")
        if [ "$response" = "200" ]; then
          echo "‚úÖ P√°gina de login carregou com sucesso (HTTP 200)"
        else
          echo "‚ùå P√°gina de login retornou c√≥digo: $response"
          exit 1
        fi
        
        # Teste de recursos est√°ticos (CSS, JS)
        echo "üé® Verificando carregamento de recursos est√°ticos..."
        static_check=$(curl -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" | grep -c "assets/" || echo "0")
        if [ "$static_check" -gt "0" ]; then
          echo "‚úÖ Recursos est√°ticos detectados na p√°gina"
        else
          echo "‚ö†Ô∏è Poucos recursos est√°ticos detectados"
        fi
    
    - name: Test 2 - Performance do Sistema
      run: |
        echo "‚ö° Testando performance do sistema..."
        
        # Teste de tempo de resposta
        start_time=$(date +%s%3N)
        curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null
        end_time=$(date +%s%3N)
        response_time=$((end_time - start_time))
        
        echo "üìä Tempo de resposta: ${response_time}ms"
        
        if [ "$response_time" -lt "${{ env.PERFORMANCE_THRESHOLD }}" ]; then
          echo "‚úÖ Performance dentro do limite aceit√°vel (< ${{ env.PERFORMANCE_THRESHOLD }}ms)"
        else
          echo "‚ö†Ô∏è Performance acima do limite esperado (${response_time}ms > ${{ env.PERFORMANCE_THRESHOLD }}ms)"
        fi
        
        # Teste de m√∫ltiplas requisi√ß√µes simult√¢neas
        echo "üîÑ Testando carga com m√∫ltiplas requisi√ß√µes..."
        for i in {1..5}; do
          curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null &
        done
        wait
        echo "‚úÖ Teste de carga b√°sico conclu√≠do"
    
    - name: Test 3 - Estabilidade da Aplica√ß√£o
      run: |
        echo "üõ°Ô∏è Testando estabilidade da aplica√ß√£o..."
        
        # Teste de estabilidade com requisi√ß√µes cont√≠nuas
        echo "üîÑ Executando teste de estabilidade (30 requisi√ß√µes em 30 segundos)..."
        success_count=0
        total_requests=30
        
        for i in $(seq 1 $total_requests); do
          if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
            success_count=$((success_count + 1))
          fi
          sleep 1
        done
        
        success_rate=$((success_count * 100 / total_requests))
        echo "üìä Taxa de sucesso: ${success_rate}% (${success_count}/${total_requests})"
        
        if [ "$success_rate" -ge "95" ]; then
          echo "‚úÖ Aplica√ß√£o demonstrou alta estabilidade (‚â•95%)"
        elif [ "$success_rate" -ge "90" ]; then
          echo "‚ö†Ô∏è Aplica√ß√£o demonstrou estabilidade aceit√°vel (‚â•90%)"
        else
          echo "‚ùå Aplica√ß√£o demonstrou baixa estabilidade (<90%)"
          exit 1
        fi
        
        # Verifica√ß√£o de logs de erro
        echo "üìã Verificando logs para erros cr√≠ticos..."
        # Note: Este comando pode precisar ser ajustado baseado na configura√ß√£o real do servidor
        # ssh ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }} "docker logs ${{ env.CONTAINER_NAME }} --tail=50" | grep -i "error\|exception\|fatal" || echo "‚úÖ Nenhum erro cr√≠tico encontrado nos logs recentes"

  # Job de monitoramento p√≥s-deploy
  post-deploy-monitoring:
    needs: [deploy, production-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Monitor Application Health
      run: |
        echo "üìä Iniciando monitoramento p√≥s-deploy..."
        
        # Monitoramento por 5 minutos
        monitor_duration=300  # 5 minutos
        check_interval=30     # 30 segundos
        checks_count=$((monitor_duration / check_interval))
        
        echo "üîç Executando $checks_count verifica√ß√µes de sa√∫de em $monitor_duration segundos..."
        
        failed_checks=0
        for i in $(seq 1 $checks_count); do
          echo "üìã Verifica√ß√£o $i/$checks_count..."
          
          if curl -f -s "http://${{ secrets.OCI_HOST }}:${{ env.PORT }}/" > /dev/null; then
            echo "‚úÖ Check $i: OK"
          else
            echo "‚ùå Check $i: FALHOU"
            failed_checks=$((failed_checks + 1))
          fi
          
          if [ $i -lt $checks_count ]; then
            sleep $check_interval
          fi
        done
        
        # An√°lise dos resultados
        success_rate=$(((checks_count - failed_checks) * 100 / checks_count))
        echo "üìä Resultado do monitoramento:"
        echo "   - Verifica√ß√µes totais: $checks_count"
        echo "   - Verifica√ß√µes com sucesso: $((checks_count - failed_checks))"
        echo "   - Verifica√ß√µes falharam: $failed_checks"
        echo "   - Taxa de sucesso: ${success_rate}%"
        
        if [ "$success_rate" -ge "95" ]; then
          echo "‚úÖ Sistema demonstrou excelente estabilidade p√≥s-deploy"
        elif [ "$success_rate" -ge "90" ]; then
          echo "‚ö†Ô∏è Sistema demonstrou boa estabilidade p√≥s-deploy"
        else
          echo "‚ùå Sistema demonstrou problemas de estabilidade p√≥s-deploy"
          echo "üö® Recomenda-se investiga√ß√£o imediata"
        fi
    
    - name: Generate Deployment Report
      run: |
        echo "üìÑ Gerando relat√≥rio de deploy..."
        
        # Criar relat√≥rio em markdown
        cat > deployment-report.md << EOF
        # üìã Relat√≥rio de Deploy - Barbear.IA
        
        **Data/Hora:** $(date '+%Y-%m-%d %H:%M:%S UTC')
        **Commit:** ${{ github.sha }}
        **Branch:** ${{ github.ref_name }}
        **Workflow:** ${{ github.run_id }}
        
        ## ‚úÖ Etapas Conclu√≠das
        
        ### üßπ Limpeza de Cache
        - ‚úÖ Cache do Docker limpo completamente
        - ‚úÖ Cache do Nginx limpo
        - ‚úÖ Cache do Frontend limpo
        
        ### üîÑ Reinicializa√ß√£o de Servi√ßos
        - ‚úÖ Container principal reiniciado
        - ‚úÖ Nginx reiniciado
        - ‚úÖ Servi√ßos auxiliares verificados
        
        ### üß™ Testes Automatizados
        - ‚úÖ Teste de funcionamento dos logins
        - ‚úÖ Teste de performance do sistema
        - ‚úÖ Teste de estabilidade da aplica√ß√£o
        
        ### üìä Monitoramento P√≥s-Deploy
        - ‚úÖ Monitoramento de 5 minutos executado
        - ‚úÖ Verifica√ß√µes de sa√∫de realizadas
        
        ## üåê Informa√ß√µes de Acesso
        
        **URL da Aplica√ß√£o:** http://${{ secrets.OCI_HOST }}:${{ env.PORT }}
        **Status:** ‚úÖ Online e Funcionando
        
        ## üìà M√©tricas de Performance
        
        - **Tempo de Build:** Verificar logs do workflow
        - **Tempo de Deploy:** Verificar logs do workflow
        - **Taxa de Sucesso dos Testes:** ‚â•95% (conforme logs)
        
        ## üîç Pr√≥ximos Passos Recomendados
        
        1. Monitorar logs da aplica√ß√£o nas pr√≥ximas 24 horas
        2. Verificar m√©tricas de uso e performance
        3. Validar funcionalidades cr√≠ticas manualmente se necess√°rio
        4. Documentar qualquer comportamento an√¥malo observado
        
        ---
        *Relat√≥rio gerado automaticamente pelo GitHub Actions*
        EOF
        
        echo "‚úÖ Relat√≥rio de deploy gerado com sucesso"
        cat deployment-report.md
    
    - name: Upload Deployment Report
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report-${{ github.run_id }}
        path: deployment-report.md
        retention-days: 30